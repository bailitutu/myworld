<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    // const声明一个只读的常量。
    // 1.一旦声明，常量的值就不能改变。
    // 2.const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
    // 3.const命令可声明对象，对象的属性方法可以增加，不唯一；


    // const PI = 3.1415;
    // PI // 3.1415
    //
    // PI = 3;
    // // TypeError: Assignment to constant variable.


    // const foo = {};
    //
    // // 为 foo 添加一个属性，可以成功
    // foo.prop = 123;
    // foo.prop // 123
    //
    // // 将 foo 指向另一个对象，就会报错
    // foo = {}; // TypeError: "foo" is read-onl


    // 下面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错
/*    const a = [];
    a.push('Hello'); // 可执行
    a.length = 0;    // 可执行
    a = ['Dave'];    // 报错*/



    // 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。

/*    window.a = 1;
    a // 1

    a = 2;
    window.a // 2*/

/*    var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
    也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。*/
/*    var a = 1;
    // 如果在 Node 的 REPL 环境，可以写成 global.a
    // 或者采用通用方法，写成 this.a
    window.a // 1

    let b = 1;
    window.b // undefined*/







</script>
</body>
</html>